name: API Deploy

on:
  workflow_dispatch:
    inputs:
      image_sha:
        description: 40-char immutable image SHA to deploy
        default: 1234567890abcdef1234567890abcdef12345678
        required: true
        type: string
      build_run_id:
        description: Run ID of the corresponding API Build workflow (produced artifacts)
        default: 999999
        required: true
        type: string

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: read
      actions: read  # needed to download artifacts from another workflow run
    env:
      REGISTRY_CANONICAL: ghcr.io/mconstant/pay2slay-api
      REGISTRY_STAGING: ghcr.io/mconstant/pay2slay-api-staging
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download Build Metadata
        uses: actions/download-artifact@v4
        with:
          # Use unique artifact name that matches the build's git SHA
          name: image-metadata-${{ inputs.image_sha }}
          path: build_artifacts
          run-id: ${{ inputs.build_run_id }}
          # Explicit token helps ensure cross-run access; action can default but being explicit avoids ambiguity
          github-token: ${{ secrets.GITHUB_TOKEN }}
        # Artifact must exist; fail fast if not
        continue-on-error: false

      - name: Validate Metadata Artifact
        id: meta
        run: |
          set -euo pipefail
          META=build_artifacts/metadata.json
          if [ ! -f "$META" ]; then
            echo "metadata artifact missing (expected $META)" >&2; exit 1; fi
          SHA_INPUT='${{ inputs.image_sha }}'
          # Validate SHA format (40 lowercase hex)
          if ! echo "$SHA_INPUT" | grep -Eq '^[0-9a-f]{40}$'; then
            echo "Provided image_sha length/format invalid" >&2; exit 2; fi
          META_SHA=$(python -c 'import json; import sys; print(json.load(open("build_artifacts/metadata.json"))["image_sha"])')
          if [ "$META_SHA" != "$SHA_INPUT" ]; then
            echo "image_sha mismatch: input=$SHA_INPUT metadata=$META_SHA" >&2; exit 3; fi
          echo '{"validated": true, "image_sha": '"$META_SHA"'}'
          echo "image_sha=${{ inputs.image_sha }}" >> $GITHUB_OUTPUT

      - name: Extract Repository (from metadata)
        id: repo
        run: |
          set -euo pipefail
          META_REPO=$(python -c 'import json; print(json.load(open("build_artifacts/metadata.json"))["repository"])')
          if [ -z "$META_REPO" ]; then
            echo "repository field missing in metadata" >&2; exit 1; fi
          echo "repository=$META_REPO" >> $GITHUB_OUTPUT
          echo "Using repository from metadata: $META_REPO"

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Validate Tag Exists & Policy
        id: validate
        run: |
          IMAGE_REF="${{ steps.repo.outputs.repository }}:${{ steps.meta.outputs.image_sha }}"
          if ! docker pull "$IMAGE_REF" >/dev/null 2>&1; then
            echo "Image tag not found: $IMAGE_REF" >&2; exit 2; fi
          # Floating tag guard (basic)
          case "$IMAGE_REF" in *:latest|*:main|*:stable) echo "Floating tag rejected" >&2; exit 3;; esac
          echo "validated_image_ref=$IMAGE_REF" >> $GITHUB_OUTPUT

      - name: Deployment Digest & Repo Guard (T028)
        id: deploy_guard
        run: |
          # Inference logic: if the resolved repository is canonical (not ending in -staging)
          # we treat this as a main deploy even if the workflow was dispatched from a
          # feature branch referencing a main-built artifact. This enables out-of-band
          # deployment runs without relaxing repository mapping policy.
          REPO="${{ steps.repo.outputs.repository }}"
          IS_MAIN_FLAG=""
          BRANCH_NAME="${GITHUB_REF##*/}"
          if [ "$BRANCH_NAME" = "main" ] || [ "$BRANCH_NAME" = "master" ]; then
            IS_MAIN_FLAG="--is-main"
          elif [[ "$REPO" != *"-staging" ]]; then
            IS_MAIN_FLAG="--is-main"
            echo "Inferring --is-main since repository is canonical ($REPO) but branch is $BRANCH_NAME" >&2
          fi
          python3 scripts/ci/check_existing_digest.py \
            --metadata build_artifacts/metadata.json \
            --repository "$REPO" \
            --image-sha "${{ steps.meta.outputs.image_sha }}" \
            ${IS_MAIN_FLAG}

      - name: SBOM Linkage Placeholder (T031)
        run: |
            echo "SBOM linkage step placeholder - to be implemented when SBOM generation available" | tee sbom-linkage.log
            echo "sbom_status=placeholder" >> $GITHUB_OUTPUT

      - name: Simulate Deployment (placeholder)
        id: deploy
        run: |
          START=$(date +%s%3N)
          echo "Applying deployment for ${{ steps.validate.outputs.validated_image_ref }}"
          sleep 1
          END=$(date +%s%3N)
          DURATION_MS=$((END-START))
          echo "deploy_duration_ms=$DURATION_MS" >> $GITHUB_OUTPUT
          echo "deploy_start_ms=$START" >> $GITHUB_OUTPUT
          echo "deploy_end_ms=$END" >> $GITHUB_OUTPUT

      - name: Log Deployment Summary
        run: |
          echo "Deployed image=${{ steps.validate.outputs.validated_image_ref }} duration_ms=${{ steps.deploy.outputs.deploy_duration_ms }} guard=ok sbom=${{ steps.deploy_guard.outcome || 'n/a' }} start_ms=${{ steps.deploy.outputs.deploy_start_ms }} end_ms=${{ steps.deploy.outputs.deploy_end_ms }}"
