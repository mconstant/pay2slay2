name: deploy-akash
on:
  workflow_dispatch:
    inputs:
      akash_network:
        description: 'Akash chain endpoint'
        required: true
        default: 'https://akash-rpc.polkachu.com:443'
      image_tag:
        description: 'Container image tag to build & deploy'
        required: true
        default: 'latest'
      ref:
        description: 'Git ref (branch or tag) to deploy (defaults to workflow run branch)'
        required: false
      akash_account_address:
        description: 'Akash wallet address (akash1...) if not set via repo variable'
        required: false

permissions:
  contents: read
  packages: write

jobs:
  build_and_push:
    runs-on: ubuntu-latest
    env:
      IMAGE_TAG: ${{ github.event.inputs.image_tag }}
      IMAGE_REPO: ghcr.io/${{ github.repository }}
    steps:
      - uses: actions/checkout@v4
      - name: Log in to GHCR
        run: echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
      - name: Build and push image
        run: |
          docker build -t ${IMAGE_REPO}:${IMAGE_TAG} .
          docker push ${IMAGE_REPO}:${IMAGE_TAG}
      - name: Install Syft (SBOM) & Cosign
        uses: sigstore/cosign-installer@v3.6.0
      - name: Generate image SBOM
        run: |
          curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b ./bin v1.14.0
          ./bin/syft ${IMAGE_REPO}:${IMAGE_TAG} -o spdx-json > image.sbom.spdx.json
          echo "Generated SBOM (image.sbom.spdx.json)" >> $GITHUB_STEP_SUMMARY
      - name: Cosign sign image (keyless)
        env:
          COSIGN_EXPERIMENTAL: 1
        run: |
            cosign sign --yes ${IMAGE_REPO}:${IMAGE_TAG}
      - name: Cosign attest SBOM
        env:
          COSIGN_EXPERIMENTAL: 1
        run: |
            cosign attest --yes --predicate image.sbom.spdx.json --type spdxjson ${IMAGE_REPO}:${IMAGE_TAG}
      - name: Set outputs
        id: meta
        run: |
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "image_repo=${IMAGE_REPO}" >> $GITHUB_OUTPUT
    outputs:
      image_tag: ${{ steps.meta.outputs.image_tag }}
      image_repo: ${{ steps.meta.outputs.image_repo }}

  deploy:
    runs-on: ubuntu-latest
    needs: build_and_push
    env:
      AKASH_CHAIN_ID: "akashnet-2"
      IMAGE_TAG: ${{ needs.build_and_push.outputs.image_tag }}
      IMAGE_REPO: ${{ needs.build_and_push.outputs.image_repo }}
  # Expect AKASH_ACCOUNT_ADDRESS to be provided as a repository variable. It will appear automatically at runtime.
    steps:
      - uses: actions/checkout@v4
      - name: Download Artifact
        uses: badgerhobbs/terraform-state@v2
        with:
            directory: ./infra/akash
            operation: download
            location: artifact
            github_token: ${{ env.GH_PAT }}
        continue-on-error: true
        env:
          GH_PAT: ${{ secrets.GH_PAT }}
      - name: Install pass
        run: |
          sudo apt-get update > /dev/null
          sudo apt-get install -yqq pass
      - name: Setup Akash CLI
        uses: LumeWeb/akash-action@cfd98517684fe809a107442d56bb4e22e1cfa0a5
        with:
          wallet-name: deployer
          mnemonic: ${{ env.AKASH_MNEMONIC }}
          cert-content: ${{ env.CERT_CONTENT }}
          cert-id: ${{ vars.AKASH_CERT_ID }}
        env:
          AKASH_MNEMONIC: ${{ secrets.AKASH_MNEMONIC }}
          CERT_CONTENT: ${{ secrets.AKASH_CERT }}
      - name: Validate required repository variables
        run: |
          ADDRESS_SOURCE="env"
          if [ -z "${AKASH_ACCOUNT_ADDRESS}" ]; then
            if [ -n "${{ github.event.inputs.akash_account_address }}" ]; then
              export AKASH_ACCOUNT_ADDRESS='${{ github.event.inputs.akash_account_address }}'
              echo "AKASH_ACCOUNT_ADDRESS=${AKASH_ACCOUNT_ADDRESS}" >> $GITHUB_ENV
              ADDRESS_SOURCE="input"
            else
              echo "Akash account address not provided. Set repo variable AKASH_ACCOUNT_ADDRESS or provide workflow input akash_account_address." >&2
              exit 1
            fi
          else
            echo "AKASH_ACCOUNT_ADDRESS present from environment (repo variable)."
          fi
          echo "Resolved Akash account address (${ADDRESS_SOURCE}): ${AKASH_ACCOUNT_ADDRESS}"
      - name: Create Akash cert
        run: |
          provider-services tx cert generate client --from deployer --yes
          provider-services tx cert publish client --from deployer --yes
          # show contents of the .akash directory
          ls -la /home/runner/.akash
        env:
          CERT_CONTENT: ${{ secrets.AKASH_CERT }}
      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
      - name: Configure cloud credentials
        env:
          AKASH_MNEMONIC: ${{ secrets.AKASH_MNEMONIC }}
        run: |
          if [ -z "$AKASH_MNEMONIC" ]; then
            echo "Missing AKASH_MNEMONIC secret" >&2
            exit 1
          fi
      - name: Terraform init/plan/apply
        id: terraform
        working-directory: infra/akash
        env:
          TF_VAR_akash_mnemonic: ${{ secrets.AKASH_MNEMONIC }}
          TF_VAR_image_tag: ${{ env.IMAGE_TAG }}
          TF_VAR_image_repo: ${{ env.IMAGE_REPO }}
          TF_VAR_akash_node: ${{ github.event.inputs.akash_network }}
          TF_VAR_akash_chain_id: ${{ env.AKASH_CHAIN_ID }}
        run: |
          if [ -z "${AKASH_ACCOUNT_ADDRESS}" ]; then
            echo "AKASH_ACCOUNT_ADDRESS not populated at runtime (should have been set earlier)." >&2
            exit 1
          fi
          export TF_VAR_akash_account_address="${AKASH_ACCOUNT_ADDRESS}"
          echo "Using TF_VAR_akash_account_address=${TF_VAR_akash_account_address}"
          terraform init -input=false
          terraform plan -input=false -out=tfplan
          terraform apply -input=false -auto-approve tfplan
          
          # Extract deployment outputs
          DEPLOYMENT_ID=$(terraform output -raw deployment_id 2>/dev/null || echo 'unavailable')
          IMAGE=$(terraform output -raw image 2>/dev/null || echo 'unavailable')
          API_URL=$(terraform output -raw api_url 2>/dev/null || echo '')
          
          echo "Deployment ID: ${DEPLOYMENT_ID}"
          echo "Image: ${IMAGE}"
          echo "API URL: ${API_URL}"
          echo "Services (JSON): $(terraform output -json services 2>/dev/null | jq -c '.' || echo 'unavailable')"
          
          # Set outputs for later steps
          echo "deployment_id=${DEPLOYMENT_ID}" >> $GITHUB_OUTPUT
          echo "api_url=${API_URL}" >> $GITHUB_OUTPUT
          
      - name: Extract UI URL
        id: ui_url
        working-directory: infra/akash
        run: |
          # Try to get URL from terraform output first
          API_URL="${{ steps.terraform.outputs.api_url }}"
          
          # If not available, try to extract from services
          if [ -z "$API_URL" ]; then
            echo "Extracting UI URL from services output..."
            services_json=$(terraform output -json services 2>/dev/null || echo '[]')
            API_URL=$(echo "$services_json" | jq -r '.[] | select(.name=="api") | .uris[0]' 2>/dev/null || echo '')
          fi
          
          if [ -z "$API_URL" ] || [ "$API_URL" = "null" ]; then
            echo "::warning::Could not extract API URL from deployment"
            API_URL="unavailable"
          fi
          
          echo "ui_url=${API_URL}" >> $GITHUB_OUTPUT
          echo "Deployed UI URL: ${API_URL}"
          
          # Add to step summary
          echo "## ðŸš€ Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Deployed UI URL:** ${API_URL}" >> $GITHUB_STEP_SUMMARY
          echo "**Deployment ID:** ${{ steps.terraform.outputs.deployment_id }}" >> $GITHUB_STEP_SUMMARY
          echo "**Image:** ${IMAGE_REPO}:${IMAGE_TAG}" >> $GITHUB_STEP_SUMMARY
          
      - name: Validate Health Check
        if: steps.ui_url.outputs.ui_url != 'unavailable' && steps.ui_url.outputs.ui_url != ''
        run: |
          UI_URL="${{ steps.ui_url.outputs.ui_url }}"
          echo "Running health check validation for: ${UI_URL}"
          
          # Install httpx if not available - fail if installation fails
          if ! pip install -q httpx; then
            echo "::error::Failed to install httpx. Cannot run health check."
            exit 1
          fi
          
          # Run health check with retries (10 attempts, 6 seconds between)
          python3 scripts/infra/validate_health.py "${UI_URL}" 10 6
          
          # Add result to summary
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## âœ… Health Check" >> $GITHUB_STEP_SUMMARY
          echo "Health check passed for: ${UI_URL}/healthz" >> $GITHUB_STEP_SUMMARY
          
      - name: Derive Banano RPC endpoint
        id: banano_rpc
        working-directory: infra/akash
        run: |
          echo "Deriving Banano RPC endpoint (internal port ${INTERNAL_PORT})..."
          services_json=$(terraform output -json services 2>/dev/null || echo '[]')
          endpoint=$(echo "$services_json" | jq -r --arg p "$INTERNAL_PORT" '.[] | select(.name=="banano") | .forwarded_ports[] | select(.port==($p|tonumber)) | "\(.host):\(.external_port)"' | grep -v '^:$' | head -n1 || true)
          echo "Banano RPC endpoint available: $endpoint"
          
      - name: Deployment Summary
        if: always()
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ðŸ“‹ Deployment Details" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **UI URL:** ${{ steps.ui_url.outputs.ui_url || 'unavailable' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployment ID:** ${{ steps.terraform.outputs.deployment_id || 'unavailable' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image Tag:** ${IMAGE_TAG}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image Repo:** ${IMAGE_REPO}" >> $GITHUB_STEP_SUMMARY
          echo "- **Provider Selection:** Cheapest audited provider (via SDL attributes)" >> $GITHUB_STEP_SUMMARY
          
      - name: Upload Artifact
        uses: badgerhobbs/terraform-state@v2
        with:
          directory: ./infra/akash
          operation: upload
          location: artifact
          github_token: ${{ env.GH_PAT }}
        env:
          GH_PAT: ${{ secrets.GH_PAT }}
